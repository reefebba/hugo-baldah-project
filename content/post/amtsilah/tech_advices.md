---
# Documentation: https://sourcethemes.com/academic/docs/managing-content/

title: "New"
subtitle: ""
summary: ""
authors: []
tags: []
categories: []
date: 2019-10-07T16:04:12+07:00
lastmod: 2019-10-07T16:04:12+07:00
featured: false
draft: true

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Focal points: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight.
image:
  caption: ""
  focal_point: ""
  preview_only: false

# Projects (optional).
#   Associate this post with one or more of your projects.
#   Simply enter your project's folder or file name without extension.
#   E.g. `projects = ["internal-project"]` references `content/project/deep-learning/index.md`.
#   Otherwise, set `projects = []`.
projects: []
---
# Open Source 

So, Hyperledger is a really unique community in the open source landscape of different blockchain technologies.
We kind of model ourselves a little bit after Apache(dev, fulltime stuff: mers, legal, Pub Rel, host meeting, phone call, mail list, events, accounting, reqr, whiteppr), and some of the other organizations out there that really are communities of communities, right? except ask coms to join as corp members of org, And so, but what members do get is some help in marketing their activities, building on top of Hyperledger projects, ways to participate at the events that we do. there's a developer community, and there's a commercial community, a corporate community...
Within Hyperledger, we have different technology code projects, essentially.
Projects like Fabric and Sawtooth, and a lot of the others that all of you will be finding out about,
but, what these projects have in common is a set of development principles around working in the public,
around, you know... even from the earliest ideas, you know, developers should be sharing that with other developers, right,
not just something they build privately, then throw over the wall, and release this open code,
but that starts out from day one as a public process, right, and multi-stakeholder as well.
So, while projects do often start out as the work of one company or one small set of developers,
we really come to trust technologies when we see that there's lots of people both using it and contributing to it.
And so, that way, we know this is actually a project that will likely outlast any one company's commitment to it, right?
That's a good basis for deciding what open source technologies to build on.
So, at Hyperledger, we're trying to make sure that each of these projects fulfills that goal of being multi-stakeholder,
of being active software development projects that get as quickly as possible to a production release,
something that organizations can actually use in real production environments, and yet, still has the flexibility to explore a new concept,
to explore a new consensus mechanism, a new way of writing smart contracts, right?
So, that balancing act is really what we're trying to strive for inside of Hyperledger.

# Advices

Someone will always tell you you’re doing it wrong

Braces should go on the next line. Braces should go on the same line. Use tabs to indent. But tabs are evil. You should use stored procedures, but actually you shouldn’t use them. You should always comment your code. But good code doesn’t need comments.

There are almost always many different approaches to a particular problem, with no single “right way.”

Someone will always tell you you’re not a real coder

HTML isn’t real coding. If you don’t use vi, you’re not really serious. Real programmers know C. Real coders don’t do Windows. Some people will never be able to learn it. You shouldn’t learn to code. You’re not a computer programmer (but I am).

“Coding” means a lot of different things to a lot of different people, and it looks different now from how it used to. 

Work with something you feel you can stick with.

As you get more comfortable, you’ll naturally start to find those tools limiting rather than helpful and look for more powerful ones. But most of the time, few people will ever even look at your code or even ask what you used — It’s what you make with it that counts.

Sticking with it is more important than the method

A common complaint with “teach yourself to code” programs and workshops is that you’ll breeze happily through the beginner material and then hit a steep curve where things get more difficult very quickly. You know how to print some lines of text on a page but have no idea where to start working on a “real,” useful project. You might feel like you were just following directions without really understanding, and blame the learning materials.

When you get to this stage, most of the tutorials and online resources available to you are much less useful because they assume you’re already an experienced and comfortable programmer. The difficulty is further compounded by the fact that “you don’t know what you don’t know.” Even trying to figure out what to learn next is a puzzle in itself.

You’ll hit this wall no matter what “learn to code” program you follow, and the only way to get past it is to persevere. This means you keep trying new things, learning more information, and figuring out, piece by piece, how to build your project. You’re a lot more likely to find success in the end if you have a clear idea of why you’re learning to code in the first place.

If you keep putting bricks on top of each other, it might take a long time but eventually you’ll have a wall. This is where that faith I mentioned earlier comes in handy. If you believe that with time and patience you can figure the whole coding thing out, in time you almost certainly will.

Every line of code represents an ethical and moral decision.

# Plan

What really differs great, good and bad coders is just complete understanding of what they do

My plan, through many iterations, ended up looking something like this:

To start, my plan was simple. At the time, I thought I was going to follow Google’s Technical Guide, so I started with their recommended introductory course, Udacity CS101
Month 0 - Udacity CS101, Harvard CS50
Month 1 - Harvard CS50, Linux, 1st Meetup, freeCodeCamp
Month 2 — YDKJS, freeCodeCamp Front End, React
Month 3 - freeCodeCamp React, CodeClub(git,miniproject), Starting freeCodeCamp Back End
Month 4 - Finished freeCodeCamp Back End, Yeggle(consume api,google,dll)
Month 5 - StockIT(simple machine learning algorithm)
Month 6 - jobSort(), Job Hunt Prep
Month 7 - Testing, Job Hunting
I also wanted to learn testing and Redux.
These calls taught me that I needed to
    be good enough to add value from day one
    be confident enough to convince them that I can add value from day one
Month 8 - Night Shift, Redux, Open Source, Onsite Interview

# To Explore

Berikut adalah keyword-keyword yg bisa di explore selanjutnya :

- Scrum
- Kanban
- Trello
- Javascript 
- TypeScript 
- StackOverflow
- Github
- Gitlab
- Bootstrap
- Jquery
- NodeJS
- Express js
- Adonis
- Angular
- Vue
- ReactJS
- Flutter
- Dart
- DBMS
- SQL
- NoSQL
- Agile
- Cloud
- CI/CD
- Docker
- AWS
- Google Cloud Platform
- Udemy
- Community
- React Native
- Redux
- MicroService
- REST API
- JSON
- JWT (Json Web Token)
- Push Notification
- Firebase
- SQLite
- Shell Script
- cron
- npm
- nodemon
- bash
- host to host
- highchart
- SOAP
- Machine Learning
- R 
- Phyton
- IoT

Silakan buat diri teman2 akrab dengan keyword2 tersebut. 

semakin akrab, insyaAllah semakin paham.

Silakan teman2 sekalian membuat rangkuman tentang semua keyword diatas.

dengan bahasa masing2(tidak boleh copy paste dari internet) harus menggunakan bahasa sendiri. 

masing2 keyword MINIMAL di jelaskan dengan 100kata.

Deadline : Kamis 17Januari 9.00

Goal dari tugas ini, bukan hanya membuat anda TAHU, tapi juga PAHAM. 

jadi, harus di BACA - ULANG - LATIH dulu baru kemudian di tuliskan ke deskripsi dengan bahasa masing2.

besok pagi akan saya kirimkan link untuk tempat pengumpulan tugasnya. 

Which technologies are best for different problems
Code written by other people
Design patterns and best practices
How to test code
CI/CD, source control, and branching strategies
The software development lifecycle and different methodologies
Working not only with your team, but with other teams, management, and clients

Further Reading
what programming, small details how computer, https, DNS, Internet, licenses, semver, changelog, json-api, gRPC
[KISS, YAGNI, DRY, SOLID, OOP Principles, Design Pattern]
TDD, compressor, file system, OS
Clean Architecture

Articles from Uncle Bob:

    https://8thlight.com/blog/uncle-bob/2011/11/22/Clean-Architecture.html
    https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html

Event Storming

    great ebook of the creator of this technique, sill not finished but finished enough to understand this technique and use it in practice: https://leanpub.com/introducing_eventstorming

DDD

    good lecture to understand basics of DDD, it is also a good position for non-technical guys: https://www.amazon.com/Domain-Driven-Design-Distilled-Vaughn-Vernon/dp/0134434420

    if you know basics of DDD in theory, you can see practical examples of how to implement it: https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577

Golang

    Go is a very simple language, I can recommend learning by these examples: https://gobyexample.com/. And trust me or not, but one night may be enough to understand Golang pretty good.

And more…

    some thoughts about important (and often forgotten) part of microservices (and monolith too) - data: http://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/

    great article which helps to understand how DDD, Clean Architecture and CQRS should work together: https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/

    Stefan Tilkov argues why we shouldn’t start with monolith, it shows why coupling is bad even if we want to build a monolith: https://martinfowler.com/articles/dont-start-monolith.html

# Blockchain

Merkle trees are used to summarize all the transactions in a block, producing an overall digital fingerprint of the entire set of transactions, providing a very efficient process to verify whether a transaction is included in a block
========
So, when deploying blockchain software, it's typically done behind a firewall,
and, anytime you have multiple organizations participating in the distributed ledger,
we will use tunneling technology and other VPN firewall tricks to make a virtual LAN exist,
so that all of their organizations can talk over it.
Different Hyperledger projects have different trade-offs.
Fabric, for instance, has a more centralized ordering service,
and so, it makes more sense to organize one of those networks into a hub-and-spoke model,
where each peer connects to the ordering service, which is run either on one of the nodes, or on a neutral third party,
and all of the gossip messages that do the consensus mechanism go through a central hub.
Now, that sounds counterintuitive because just distributed ledgers are supposed to be distributed...
they still are, they're distributed in the sense that the blockchain itself is replicated amongst all of the nodes,
and so, your data is much more resilient to disruption... resilient against disruption.
But, the coordination can still be done in a fairly centralized manner.
With Sawtooth, it is not so much the case, right?
The organization of the network for Sawtooth is probably more of like a star model,
where you pick some subset of nodes, and your node connects to those and, as long as all nodes are fairly well connected,
they can all eventually talk to each other, either one hop, or two hops, or three hops away, depending on the size of your network.
With Iroha, they... their topology is a lot different than the others,
because they designed their distributed ledger to function well in a mobile environment,
where a lot of the clients are intermittently connected.
So, they're mobile phones that can be connected and disconnected at random.
So, their structure is more of a layered network, where the end clients' mobile phones submit transactions to servers,
which then, amongst the servers, do the distributed ledger.
And there's no right answer, right?
The business process dictates which one you choose, but the security is pretty much the same in all of these.
We use cryptography and digital signatures to validate all the messages.
So, tampering with messages is essentially impossible.
The immutability of the distributed ledger is guaranteed by the cryptography,
but the nature of the trusted network, of the permissioned network, means that we have to treat it like any other back-office service.
You want to deploy it behind a firewall, you want to use tunneling to connect between nodes across the Internet,
and you want to maintain it, just like any other service that deals with Internet traffic...
you have firewalls, and load balancers, and things like that.

There are a number of consensus mechanisms or algorithms.
One is Proof of Work. Another is Proof of Stake.
There's also Proof of Elapsed Time, as well as Simplified Byzantine Fault Tolerance.
    
# Eat that frog

“Throughout my career, I have discovered and rediscovered a simple truth. The ability to concentrate single-mindedly on your most important task, to do it well, and to finish it completely, is the key to great success, achievement, respect, status, and happiness in life.”

    — Brian Tracy, Eat That Frog

    “Mark Twain once said that if the first thing you do each morning is to eat a live frog, you can go through the day with the satisfaction of knowing that this is probably the worst thing that is going to happen to you all day long.”

    — Eat That Frog p.2

    “Your ‘frog’ is your biggest, most important task, the one you are most likely to procrastinate on if you don’t do something about it. It is also the one task that can have the greatest positive impact on your life and results at the moment.”

    — Eat That Frog p.2

    “One of the very worst uses of time is to do something very well that need not be done at all”

    — Eat That Frog p.10

    “I’d finally created something people wanted. It was like I’d written a hit song. Once you have a hit, all the locked doors open wide. People love it so much it seems to promote itself. Don’t persistently do what’s not working.”

    — Derek Sivers about CDBaby

    “What one skill, if I developed and did it in an excellent fashion, would have the greatest positive impact on my career?”

    Look into yourself for the answer. Ask your boss this question. Ask your coworkers. Ask your friends and your family. Whatever the answer is, find out and then go to work to bring up your performance in this area.

    — Eat That Frog p.45

Step 3 — Choose Your Top 3 Frogs

    “You can get your time and your life under control only to the degree to which you discontinue lower-value activities.”

    — Eat That Frog p. 34

The Biggest, Ugliest Frog in the World is Finishing

    “The sad fact is that ‘almost done’ probably meant ‘not yet started.’ Don’t let this happen to you.”

    — Eat That Frog p.58
